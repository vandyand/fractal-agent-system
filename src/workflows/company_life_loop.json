[
  {
    "id": "company_life_loop_tab",
    "type": "tab",
    "label": "Company Life Loop",
    "disabled": false,
    "info": "Main autonomous company life cycle - the heartbeat of the digital company"
  },
  {
    "id": "life_loop_timer",
    "type": "inject",
    "z": "company_life_loop_tab",
    "name": "Life Loop Timer",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "30",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "{\"timestamp\": \"\", \"cycle\": 0}",
    "payloadType": "json",
    "x": 150,
    "y": 100,
    "wires": [["life_cycle_coordinator"]]
  },
  {
    "id": "life_cycle_coordinator",
    "type": "function",
    "z": "company_life_loop_tab",
    "name": "Life Cycle Coordinator",
    "func": "// Main company life cycle coordinator\n// This is the brain of our autonomous digital company\n\nconst timestamp = new Date().toISOString();\nconst cycle = (msg.payload.cycle || 0) + 1;\n\n// Company life cycle phases\nconst phases = [\n    'monitor',      // Monitor market, customers, systems\n    'analyze',      // Analyze data and opportunities\n    'plan',         // Plan actions and strategies\n    'execute',      // Execute business processes\n    'optimize'      // Optimize and improve\n];\n\nconst currentPhase = phases[cycle % phases.length];\n\n// Determine what needs to be done in this cycle\nconst tasks = [];\n\n// Always monitor system health\nif (currentPhase === 'monitor') {\n    tasks.push({\n        type: 'health_check',\n        priority: 'high',\n        agent: 'system_monitor'\n    });\n    \n    tasks.push({\n        type: 'market_monitor',\n        priority: 'medium',\n        agent: 'market_analyst'\n    });\n}\n\n// Analyze opportunities and threats\nif (currentPhase === 'analyze') {\n    tasks.push({\n        type: 'opportunity_analysis',\n        priority: 'high',\n        agent: 'opportunity_analyzer'\n    });\n    \n    tasks.push({\n        type: 'risk_assessment',\n        priority: 'medium',\n        agent: 'risk_analyzer'\n    });\n}\n\n// Plan business actions\nif (currentPhase === 'plan') {\n    tasks.push({\n        type: 'strategy_planning',\n        priority: 'high',\n        agent: 'strategy_planner'\n    });\n    \n    tasks.push({\n        type: 'resource_allocation',\n        priority: 'medium',\n        agent: 'resource_manager'\n    });\n}\n\n// Execute business processes\nif (currentPhase === 'execute') {\n    tasks.push({\n        type: 'business_execution',\n        priority: 'high',\n        agent: 'business_executor'\n    });\n    \n    tasks.push({\n        type: 'customer_interaction',\n        priority: 'medium',\n        agent: 'customer_service'\n    });\n}\n\n// Optimize and improve\nif (currentPhase === 'optimize') {\n    tasks.push({\n        type: 'performance_optimization',\n        priority: 'high',\n        agent: 'optimizer'\n    });\n    \n    tasks.push({\n        type: 'process_improvement',\n        priority: 'medium',\n        agent: 'process_improver'\n    });\n}\n\n// Add urgent tasks that need immediate attention\nconst urgentTasks = msg.payload.urgentTasks || [];\nif (urgentTasks.length > 0) {\n    tasks.unshift(...urgentTasks.map(task => ({\n        ...task,\n        priority: 'urgent'\n    })));\n}\n\nmsg.payload = {\n    timestamp,\n    cycle,\n    phase: currentPhase,\n    tasks,\n    companyState: {\n        phase: currentPhase,\n        cycle,\n        timestamp,\n        activeAgents: [],\n        pendingTasks: tasks.length,\n        completedTasks: 0,\n        revenue: 0,\n        customers: 0,\n        marketPosition: 'startup'\n    }\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 100,
    "wires": [["task_queue_manager"]]
  },
  {
    "id": "task_queue_manager",
    "type": "function",
    "z": "company_life_loop_tab",
    "name": "Task Queue Manager",
    "func": "// Manage task queue and prioritize execution\n\nconst { tasks, companyState } = msg.payload;\n\n// Sort tasks by priority\nconst priorityOrder = { 'urgent': 0, 'high': 1, 'medium': 2, 'low': 3 };\ntasks.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);\n\n// Check flow registry for available agents\nconst availableAgents = [\n    'system_monitor',\n    'market_analyst', \n    'opportunity_analyzer',\n    'risk_analyzer',\n    'strategy_planner',\n    'resource_manager',\n    'business_executor',\n    'customer_service',\n    'optimizer',\n    'process_improver'\n];\n\n// Assign tasks to available agents\nconst assignedTasks = tasks.map(task => ({\n    ...task,\n    assignedAgent: availableAgents.includes(task.agent) ? task.agent : 'general_agent',\n    status: 'queued',\n    assignedAt: new Date().toISOString()\n}));\n\n// Update company state\ncompanyState.pendingTasks = assignedTasks.length;\ncompanyState.availableAgents = availableAgents.length;\n\nmsg.payload = {\n    ...msg.payload,\n    assignedTasks,\n    companyState\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 650,
    "y": 100,
    "wires": [["agent_orchestrator"]]
  },
  {
    "id": "agent_orchestrator",
    "type": "function",
    "z": "company_life_loop_tab",
    "name": "Agent Orchestrator",
    "func": "// Orchestrate agent execution and collect results\n\nconst { assignedTasks, companyState } = msg.payload;\n\n// Simulate agent execution (in real implementation, this would trigger actual agents)\nconst executionResults = assignedTasks.map(task => {\n    // Simulate task execution\n    const executionTime = Math.random() * 5000 + 1000; // 1-6 seconds\n    const success = Math.random() > 0.1; // 90% success rate\n    \n    return {\n        taskId: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        taskType: task.type,\n        agent: task.assignedAgent,\n        status: success ? 'completed' : 'failed',\n        executionTime,\n        result: success ? {\n            message: `Successfully executed ${task.type}`,\n            value: Math.random() * 1000, // Simulated business value\n            timestamp: new Date().toISOString()\n        } : {\n            error: `Failed to execute ${task.type}`,\n            timestamp: new Date().toISOString()\n        },\n        timestamp: new Date().toISOString()\n    };\n});\n\n// Update company metrics\nconst completedTasks = executionResults.filter(r => r.status === 'completed').length;\nconst totalValue = executionResults\n    .filter(r => r.status === 'completed')\n    .reduce((sum, r) => sum + (r.result.value || 0), 0);\n\ncompanyState.completedTasks = completedTasks;\ncompanyState.revenue += totalValue;\ncompanyState.successRate = completedTasks / assignedTasks.length;\n\nmsg.payload = {\n    ...msg.payload,\n    executionResults,\n    companyState,\n    metrics: {\n        totalTasks: assignedTasks.length,\n        completedTasks,\n        successRate: companyState.successRate,\n        totalValue,\n        averageExecutionTime: executionResults.reduce((sum, r) => sum + r.executionTime, 0) / executionResults.length\n    }\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 900,
    "y": 100,
    "wires": [["metrics_collector", "flow_registry_updater"]]
  },
  {
    "id": "metrics_collector",
    "type": "function",
    "z": "company_life_loop_tab",
    "name": "Metrics Collector",
    "func": "// Collect and store company metrics\n\nconst { metrics, companyState, executionResults } = msg.payload;\n\n// Store metrics in persistent storage\nconst metricsData = {\n    timestamp: new Date().toISOString(),\n    cycle: companyState.cycle,\n    phase: companyState.phase,\n    metrics,\n    companyState,\n    executionResults\n};\n\n// In a real implementation, this would save to a database\n// For now, we'll just pass it along\nmsg.payload = {\n    ...msg.payload,\n    storedMetrics: metricsData\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1150,
    "y": 100,
    "wires": [["company_dashboard"]]
  },
  {
    "id": "flow_registry_updater",
    "type": "function",
    "z": "company_life_loop_tab",
    "name": "Flow Registry Updater",
    "func": "// Update flow registry with new tasks and results\n\nconst { executionResults, companyState } = msg.payload;\n\n// Update flow registry with completed tasks\nconst registryUpdates = executionResults.map(result => ({\n    flowId: result.taskId,\n    type: result.taskType,\n    agent: result.agent,\n    status: result.status,\n    lastExecuted: result.timestamp,\n    executionTime: result.executionTime,\n    successRate: result.status === 'completed' ? 1 : 0\n}));\n\n// Check if any new flows need to be created\nconst newFlowsNeeded = executionResults\n    .filter(r => r.status === 'completed' && r.result.value > 500) // High-value tasks\n    .map(r => ({\n        type: r.taskType,\n        priority: 'high',\n        trigger: 'automatic',\n        agent: r.agent\n    }));\n\nmsg.payload = {\n    ...msg.payload,\n    registryUpdates,\n    newFlowsNeeded\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1150,
    "y": 200,
    "wires": [["flow_registry"]]
  },
  {
    "id": "company_dashboard",
    "type": "debug",
    "z": "company_life_loop_tab",
    "name": "Company Dashboard",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1400,
    "y": 100,
    "wires": []
  },
  {
    "id": "flow_registry",
    "type": "debug",
    "z": "company_life_loop_tab",
    "name": "Flow Registry",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 1400,
    "y": 200,
    "wires": []
  },
  {
    "id": "emergency_stop",
    "type": "inject",
    "z": "company_life_loop_tab",
    "name": "Emergency Stop",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "{\"action\": \"stop\", \"reason\": \"emergency\"}",
    "payloadType": "json",
    "x": 150,
    "y": 300,
    "wires": [["emergency_handler"]]
  },
  {
    "id": "emergency_handler",
    "type": "function",
    "z": "company_life_loop_tab",
    "name": "Emergency Handler",
    "func": "// Handle emergency stops and system shutdowns\n\nconst { action, reason } = msg.payload;\n\nif (action === 'stop') {\n    console.log(`üö® EMERGENCY STOP: ${reason}`);\n    \n    // Stop the life loop timer\n    node.send([null, {\n        payload: {\n            action: 'stop_timer',\n            reason: reason,\n            timestamp: new Date().toISOString()\n        }\n    }]);\n    \n    // Notify all agents to stop\n    node.send([null, null, {\n        payload: {\n            action: 'notify_agents',\n            message: 'Emergency stop initiated',\n            timestamp: new Date().toISOString()\n        }\n    }]);\n}\n\nreturn msg;",
    "outputs": 3,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 300,
    "wires": [["emergency_log"], ["timer_controller"], ["agent_notifier"]]
  },
  {
    "id": "emergency_log",
    "type": "debug",
    "z": "company_life_loop_tab",
    "name": "Emergency Log",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 650,
    "y": 300,
    "wires": []
  },
  {
    "id": "timer_controller",
    "type": "function",
    "z": "company_life_loop_tab",
    "name": "Timer Controller",
    "func": "// Control the life loop timer\n\nconst { action } = msg.payload;\n\nif (action === 'stop_timer') {\n    // In a real implementation, this would stop the inject node\n    console.log('‚èπÔ∏è Life loop timer stopped');\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 650,
    "y": 400,
    "wires": [["timer_status"]]
  },
  {
    "id": "timer_status",
    "type": "debug",
    "z": "company_life_loop_tab",
    "name": "Timer Status",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 900,
    "y": 400,
    "wires": []
  },
  {
    "id": "agent_notifier",
    "type": "function",
    "z": "company_life_loop_tab",
    "name": "Agent Notifier",
    "func": "// Notify all agents of system events\n\nconst { action, message } = msg.payload;\n\nif (action === 'notify_agents') {\n    console.log(`üì¢ Agent notification: ${message}`);\n    \n    // In a real implementation, this would send messages to all agents\n    // For now, just log the notification\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 650,
    "y": 500,
    "wires": [["agent_status"]]
  },
  {
    "id": "agent_status",
    "type": "debug",
    "z": "company_life_loop_tab",
    "name": "Agent Status",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 900,
    "y": 500,
    "wires": []
  }
] 